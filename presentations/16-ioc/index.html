<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>IoC in .NET</title>
    <meta name="description" content="Inversion of control approach in .NET">
    <meta name="author" content="Valentine Radchuk">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="http://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="http://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../../shared/css/reveal.css">
    <link rel="stylesheet" href="../../shared/css/theme/league.css" id="theme">
    <link type="text/css" rel="stylesheet" href="../../shared/fsharp.formatting/styles/style.css" />
    <link type="text/css" rel="stylesheet" href="../../shared/fsharp.formatting/styles/deedle.css" />
    <link type="text/css" rel="stylesheet" href="../../shared/css/custom.css" />
    <script src="../../shared/fsharp.formatting/styles/tips.js" type="text/javascript"></script>
    <link rel="shortcut icon" type="image/png" href="../../shared/favicon.png">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../../shared/css/fsreveal.css">
    <link rel="stylesheet" href="../../shared/lib/css/zenburn.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = '../../shared/css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
    </script>
    <!--[if lt IE 9]>
    <script src="../../shared/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
    <div class="reveal">
        
        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section >

<h2>C# course</h2>

<h4>Lecture 16</h4>

<h1>IoC in .NET</h1>

</section>

<section >

<h3>What is Inversion of Control</h3>

<p><strong>Inversion of Control</strong> - is a common principle for writting low coupled code.
Imversion control could be implemented via:</p>

<ul>
<li>factory pattern</li>
<li>service locator pattern</li>
<li>depenency injection</li>
<li>strategy pattern</li>
<li>using events\delegates</li>
<li>using interfaces</li>
</ul>

</section>

<section >

<h3>IoC vs DI vs DIP</h3>

<ul>
<li>IoC (Inversion of Control) - most general term indicating idea of invoking client code from a framework</li>
<li>DI (Dependency Injection) - set of patterns to pass dependencies to a class</li>
<li>DIP - (Dependency Inversion Principle) - tells that class should depend on abstractions from the same or higher level</li>
</ul>

<a href="http://sergeyteplyakov.blogspot.com/2014/11/di-vs-dip-vs-ioc.html">More info about the terms (ru)</a>

</section>

<section >

<h3>Reasons to use IoC in your project</h3>

<ul>
<li>reduce coupling</li>
<li>remove direct dependencies between classes</li>
<li>force use abstractions instead of implementations</li>
<li>manage dependencies in external configuration</li>
<li>minimize effort on injecting other implementation</li>
<li>increaze testability of code</li>
</ul>

</section>

<section >

<section >

<h3>How does IoC works</h3>

<p><img src="images\IoC-basics.jpg" alt="" /></p>

<a href="https://dotnetfiddle.net/K9bYLb">Sample code without DI</a>  
<br />
<a href="https://dotnetfiddle.net/2MRbRK">Sample code with DI</a>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Constructor injection</h3>

<p>Pass the object of the defined class into the constructor of the dependent class for its <em><strong>entire lifetime</strong></em></p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">class</span> Watcher {
    INofificationAction action <span class="o">=</span> <span class="k">null</span>;

    <span class="k">public</span> Watcher(INofificationAction concreteAction) {
        <span class="k">this</span>.action <span class="o">=</span> concreteAction;
    }

    <span class="k">public</span> <span class="k">void</span> Notify(<span class="k">string</span> message) {   
        action.ActOnNotification(message);
    }
}
</code></pre></td></tr></table>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">var</span> writer <span class="o">=</span> <span class="k">new</span> EventLogWriter();
<span class="k">var</span> watcher <span class="o">=</span> <span class="k">new</span> Watcher(writer);
watcher.Notify(<span class="s">"Sample message to log"</span>);
</code></pre></td></tr></table>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Method injection</h3>

<p>To work in a method with different concrete class we have to pass the dependency in the method only</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">class</span> Watcher
{
    <span class="k">public</span> <span class="k">void</span> Notify(INofificationAction concreteAction, <span class="k">string</span> message)
    {
        action.ActOnNotification(message);
    }
}
</code></pre></td></tr></table>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">EventLogWriter writer <span class="o">=</span> <span class="k">new</span> EventLogWriter();
<span class="k">var</span> watcher <span class="o">=</span> <span class="k">new</span> Watcher();
watcher.Notify(writer, <span class="s">"Sample message to log"</span>);
</code></pre></td></tr></table>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Property injection</h3>

<p>If the responsibility of selection of concrete class and invocation of method are in separate places we need property injection</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">class</span> Watcher {
    <span class="k">public</span> INofificationAction Action { get; set ; }    

    <span class="k">public</span> <span class="k">void</span> Notify(<span class="k">string</span> message) {   
        action.ActOnNotification(message);
    }
}
</code></pre></td></tr></table>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">var</span> writer <span class="o">=</span> <span class="k">new</span> EventLogWriter();
<span class="k">var</span> watcher <span class="o">=</span> <span class="k">new</span> Watcher();
<span class="c">// This can be done in some class</span>
watcher.Action <span class="o">=</span> writer;
<span class="c">// This can be done in some other class</span>
watcher.Notify(<span class="s">"Sample message to log"</span>);
</code></pre></td></tr></table>

</section>

</section>

<section >

<section >

<h3>IoC containers</h3>

<p>IoC containers are used to:</p>

<ul>
<li>automatically inject dependencies</li>
<li>manage lifecycle of dependencies</li>
<li>manage dependencies relationship</li>
<li>split creation dependencies and configuration relationships</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>DI cons</h3>

<ul>
<li>high learning curve</li>
<li>constructors may look complicated</li>
<li>code may seem "magic" for those who don't know DI</li>
<li>overkill for small projects</li>
<li>makes classes hard to use outside IoC container</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>IoC containers in .NET world</h3>

<ul>
<li><a href="www.ninject.org">Ninject</a></li>
<li><a href="https://unity.codeplex.com/">Unity</a></li>
<li><a href="http://www.castleproject.org/">Castle.Windsor</a></li>
<li><a href="http://autofac.org/">Autofac</a></li>
<li><a href="http://docs.structuremap.net/">StructureMap</a></li>
</ul>

<p><a href="http://www.palmmedia.de/blog/2011/8/30/ioc-container-benchmark-performance-comparison">Comparison table</a></p>

<p><a href="http://philipm.at/2011/di_speed.html">Another comparison table</a></p>

<p><a href="http://www.iocbattle.com/">IoC Battle</a></p>

</section>

</section>

<section >

<h3>Autofac - overview</h3>

<ul>
<li>open source project</li>
<li>automates constructor, method and property injection</li>
<li>ligh-weight and fast enought</li>
<li>has lower learning curve comparing to other containers</li>
<li>could be configured either via code or xml configuration</li>
<li>available for all .NET technologies (WPF, ASP MVC, Web API, WinPhone 8, Win RT etc)</li>
<li>supports modules and automated type loading from an assembly</li>
<li>supports interceptors</li>
</ul>

<p><a href="http://autofac.org/">Autofac homepage</a></p>

</section>

<section >

<section >

<h3>Sample container - manual resolution</h3>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
<span class="l">6: </span>
<span class="l">7: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">static</span> <span class="k">void</span> Main(<span class="k">string</span>[] args)
{
  <span class="k">var</span> consoleOutput <span class="o">=</span> <span class="k">new</span> ConsoleOutput();
  <span class="k">var</span> writer <span class="o">=</span> <span class="k">new</span> TodayWriter(consoleOutput);
  
  writer.WriteDate();
}
</code></pre></td></tr></table>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Sample container - resulution with Autofac</h3>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">static</span> <span class="k">void</span> Main(<span class="k">string</span>[] args)
{
  <span class="c">// register types for DI</span>
  <span class="k">var</span> builder <span class="o">=</span> <span class="k">new</span> ContainerBuilder();
  <span class="c">// dependency</span>
  builder.RegisterType&lt;ConsoleOutput&gt;().As&lt;IOutput&gt;();  
  <span class="c">// class to inject dependency</span>
  builder.RegisterType&lt;TodayWriter&gt;().As&lt;IDateWriter&gt;();
  <span class="k">var</span> container <span class="o">=</span> builder.Build();
  <span class="c">// resolve types and use instances with injected objects</span>
  <span class="k">using</span> (<span class="k">var</span> scope <span class="o">=</span> Container.BeginLifetimeScope())
  {
    <span class="k">var</span> writer <span class="o">=</span> scope.Resolve&lt;IDateWriter&gt;();
    writer.WriteDate();
  }
}
</code></pre></td></tr></table>

</section>

</section>

<section >

<h3>Glossary</h3>

<ul>
<li><strong>Container</strong> - manager of application Components</li>
<li><strong>Component</strong> - class that declares a Service and dependencies it uses</li>
<li><strong>Service</strong> - is a contract (interface) between Dependencies</li>
<li><strong>Dependency</strong> - Service required by a Component</li>
<li><strong>Registration</strong> - adding Component to Container</li>
<li><strong>Scope</strong> - is context where Instance of a component will be shared by other Components</li>
</ul>

</section>

<section >

<h3>Registering and resolving components</h3>

<section data-markdown>
    <script type="text/template">
<img style="border: 0px;" src="images/RegisterComponents_1.png" alt="Create container" /> <!-- .element: class="fragment" data-fragment-index="1" -->   
<img style="border: 0px;" src="images/RegisterComponents_2.png" alt="Create container" /> <!-- .element: class="fragment" data-fragment-index="2" -->  
<img style="border: 0px;" src="images/RegisterComponents_3.png" alt="Create container" /> <!-- .element: class="fragment" data-fragment-index="3" -->  
<img style="border: 0px;" src="images/RegisterComponents_4.png" alt="Create container" /> <!-- .element: class="fragment" data-fragment-index="4" -->  
<img style="border: 0px;" src="images/RegisterComponents_5.png" alt="Create container" /> <!-- .element: class="fragment" data-fragment-index="5" -->  
    </script>
</section>

</section>

<section >

<section >

<h3>Register by Type</h3>

<p>Components generated by reflection are registered by type:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.RegisterType&lt;ConsoleLogger&gt;();
builder.RegisterType(<span class="k">typeof</span>(ConfigReader));
</code></pre></td></tr></table>

<p>Autofac automatically uses the matching constructor</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">public</span> <span class="k">class</span> MyComponent <span class="o">:</span> IService {
    <span class="k">public</span> MyComponent() { <span class="c">/* ... */</span> }
    <span class="k">public</span> MyComponent(ILogger logger) { <span class="c">/* ... */</span> }
    <span class="k">public</span> MyComponent(ILogger logger, IConfigReader reader) { <span class="c">/* ... */</span> }
}
</code></pre></td></tr></table>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.RegisterType&lt;MyComponent&gt;();
builder.RegisterType&lt;ConsoleLogger&gt;().As&lt;ILogger&gt;();
<span class="k">var</span> container <span class="o">=</span> builder.Build();
<span class="c">//...</span>
<span class="k">var</span> component <span class="o">=</span> container.Resolve&lt;MyComponent&gt;();
</code></pre></td></tr></table>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Register by type specifying constructor</h3>

<p>You can manually choose a particular constructor to use and override the automatic choice:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.RegisterType&lt;MyComponent&gt;()
       .UsingConstructor(<span class="k">typeof</span>(ILogger), <span class="k">typeof</span>(IConfigReader));
</code></pre></td></tr></table>

</section>

</section>

<section >

<h3>Instance components</h3>

<p>You can add pre-generate an instance of an object and add it to the container:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">var</span> output <span class="o">=</span> <span class="k">new</span> StringWriter();
builder.RegisterInstance(output).As&lt;TextWriter&gt;();
</code></pre></td></tr></table>

<p>To avoid Autofac dispose the instance use:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">var</span> output <span class="o">=</span> <span class="k">new</span> StringWriter();
builder.RegisterInstance(output).As&lt;TextWriter&gt;()
       .ExternallyOwned();
</code></pre></td></tr></table>

</section>

<section >

<section >

<h3>Lambda expression components</h3>

<p>Autofac can create a component using lambda expression:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.Register(c <span class="o">=</span><span class="o">&gt;</span> <span class="k">new</span> A(c.Resolve&lt;B&gt;()));
<span class="c">// parameter c is an component context of type IComponentContext</span>
</code></pre></td></tr></table>

<p>It is important to use component context rather than a closure to access the container</p>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Lambda expression components - cases</h3>

<p>Pass constant value to constructor:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.Register(c <span class="o">=</span><span class="o">&gt;</span> <span class="k">new</span> UserSession(DateTime.Now.AddMinutes(25)));
</code></pre></td></tr></table>

<p>Property Injection:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.Register(c <span class="o">=</span><span class="o">&gt;</span> <span class="k">new</span> A(){ MyB <span class="o">=</span> c.ResolveOptional&lt;B&gt;() });
<span class="c">// ResolveOptional will try to resolve dependency but won't throw exception</span>
</code></pre></td></tr></table>

<p>Conditional creation:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.Register&lt;CreditCard&gt;((c, p) <span class="o">=</span><span class="o">&gt;</span> {
      <span class="k">var</span> accountId <span class="o">=</span> p.Named&lt;<span class="k">string</span>&gt;(<span class="s">"accountId"</span>);
      <span class="k">var</span> result <span class="o">=</span> accountId.StartsWith(<span class="s">"9"</span>) <span class="o">?</span> <span class="k">new</span> GoldCard(accountId) <span class="o">:</span> <span class="k">new</span> StandardCard(accountId);
      <span class="k">return</span> result;
    });
</code></pre></td></tr></table>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">var</span> card <span class="o">=</span> container.Resolve&lt;CreditCard&gt;(<span class="k">new</span> NamedParameter(<span class="s">"accountId"</span>, <span class="s">"12345"</span>));
</code></pre></td></tr></table>

</section>

</section>

<section >

<section >

<h3>Services vs. Components</h3>

<p>When registering components, Autofac should be specified with services that component exposes 
<br />
By default, registration exposes itself as the type registered:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="c">// This exposes the service CallLogger</span>
builder.RegisterType&lt;CallLogger&gt;();
</code></pre></td></tr></table>

<p>Components can only be resolved by the services they expose</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="c">// This will work because the component</span>
<span class="c">// exposes the type by default:</span>
scope.Resolve&lt;CallLogger&gt;();
<span class="c">// This will NOT work</span>
scope.Resolve&lt;ILogger&gt;();
</code></pre></td></tr></table>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Exposing multiple services</h3>

<p>Component can expose multiple services:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.RegisterType&lt;CallLogger&gt;()
       .As&lt;ILogger&gt;()
       .As&lt;ICallInterceptor&gt;();
</code></pre></td></tr></table>

<p>Component can expose even itself as a service along with others:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.RegisterType&lt;CallLogger&gt;()
       .As&lt;ILogger&gt;()
       .As&lt;ICallInterceptor&gt;()
       .AsSelf();
</code></pre></td></tr></table>

</section>

</section>

<section >

<h3>Default registration</h3>

<p>Autofac uses the last registered component as the default provider of that service:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.Register&lt;ConsoleLogger&gt;().As&lt;ILogger&gt;();
builder.Register&lt;FileLogger&gt;().As&lt;ILogger&gt;();
<span class="c">//...</span>
scope.Resolve&lt;ILogger&gt;(); <span class="c">// FileLogger will be returned</span>
</code></pre></td></tr></table>

<p>To override this behavior, use the PreserveExistingDefaults() modifier:</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.Register&lt;ConsoleLogger&gt;().As&lt;ILogger&gt;();
builder.Register&lt;FileLogger&gt;().As&lt;ILogger&gt;().PreserveExistingDefaults();
<span class="c">//...</span>
scope.Resolve&lt;ILogger&gt;(); <span class="c">// ConsoleLogger will be returned</span>
</code></pre></td></tr></table>

</section>

<section >

<h3>Scopes</h3>

<p>The <em><strong>scope</strong></em> of a service is the area where that service can be shared with other components that consume it</p>

<p>Scopes in Autofac:</p>

<ul>
<li>are nestable and they control how components are share</li>
<li>track disposable objects and dispose of them when the lifetime scope is disposed</li>
</ul>

<p class="fragment highlight-current-blue">It is important to always resolve services from a lifetime scope and not the root container</p>

</section>

<section >

<h3>Lifetime options</h3>

<p>Once registered, components can be configured with their lifetime</p>

<ul>
<li>Instance Per Dependency - create new instance on each service request</li>
<li>Single Instance - aka Singleton</li>
<li>Instance Per LifeTime Scope - same instance in single scope</li>
<li>Instance Per Matching LifeTime Scope - singleton within the named scope</li>
</ul>

<p><a href="http://autofac.readthedocs.org/en/latest/lifetime/instance-scope.html">More about lifetime scopes</a></p>

</section>

<section >

<section >

<h3>Modules</h3>

<p>A module is a class that can be used to bundle up a set of related components behind a 'facade' to simplify configuration and deployment.</p>

<h4>Modules:</h4>

<ul>
<li>Decreased Configuration Complexity</li>
<li>Configuration Parameters are Explicit</li>
<li>Abstraction from the Internal Application Architecture</li>
<li>Better Type Safety</li>
<li>Dynamic Configuration</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Inversion of control approach in .NET" theme="league" title="IoC in .NET" transition="default">

<h3>Module example</h3>

<p>Create module</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs"><span class="k">public</span> <span class="k">class</span> CarTransportModule <span class="o">:</span> Module {
  <span class="k">public</span> <span class="k">bool</span> ObeySpeedLimit { get; set; } 
  <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> Load(ContainerBuilder builder) {
    builder.Register(c <span class="o">=</span><span class="o">&gt;</span> <span class="k">new</span> Car(c.Resolve&lt;IDriver&gt;())).As&lt;IVehicle&gt;();

    <span class="k">if</span> (ObeySpeedLimit)
      builder.Register(c <span class="o">=</span><span class="o">&gt;</span> <span class="k">new</span> SaneDriver()).As&lt;IDriver&gt;();
    <span class="k">else</span>
      builder.Register(c <span class="o">=</span><span class="o">&gt;</span> <span class="k">new</span> CrazyDriver()).As&lt;IDriver&gt;();
  }
}
</code></pre></td></tr></table>

<p>Register module</p>

<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="cs">builder.RegisterModule(<span class="k">new</span> CarTransportModule() {
    ObeySpeedLimit <span class="o">=</span> <span class="k">true</span>
});
</code></pre></td></tr></table>

</section>

</section>

<section >

<h3>Autofac Integration</h3>

<p>Autofac is integrated with following technologies:</p>

<ul>
<li>ASP.NET
<ul>
<li>OWIN</li>
<li>MVC</li>
<li>Web API</li>
<li>SignalR</li>
<li>Web Forms</li>
</ul></li>
<li>WCF</li>
<li>Managed Extensibility Framework</li>
<li>NHibernate</li>
<li>Moq</li>
</ul>

<p><a href="http://autofac.readthedocs.org/en/latest/integration/index.html">Full list</a></p>

</section>



        </div>
    </div>
    <script src="../../shared/lib/js/head.min.js"></script>
    <script src="../../shared/js/reveal.js"></script>
    <script>
		// Add the nohighlight class and data-noescape attribute to code elements that have already been formatted by FSharp.Formatting
        $('pre.highlighted code').addClass('nohighlight').attr('data-noescape', '');
		
        // Full list of configuration options available here:
        // https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

            // Parallax scrolling
            // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
            // parallaxBackgroundSize: '2100px 900px',

            // Optional libraries used to extend on reveal.js
            dependencies: [
                { src: '../../shared/lib/js/classList.js', condition: function () { return !document.body.classList; } },
                { src: '../../shared/plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: '../../shared/plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: '../../shared/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
                { src: '../../shared/plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
                { src: '../../shared/plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
            ]
        });

    </script>
</body>
</html>

