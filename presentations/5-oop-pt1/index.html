<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>CSharp - OOP</title>
    <meta name="description" content="Object-oriented programming in C#">
    <meta name="author" content="Valentine Radchuk">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="//code.jquery.com/jquery-1.8.0.js"></script>
    <script src="//code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../../shared/css/reveal.css">
    <link rel="stylesheet" href="../../shared/css/theme/league.css" id="theme">
    <link type="text/css" rel="stylesheet" href="../../shared/fsharp.formatting/styles/style.css" />
    <link type="text/css" rel="stylesheet" href="../../shared/fsharp.formatting/styles/deedle.css" />
    <link type="text/css" rel="stylesheet" href="../../shared/css/custom.css" />
    <script src="../../shared/fsharp.formatting/styles/tips.js" type="text/javascript"></script>
    <link rel="shortcut icon" type="image/png" href="../../shared/favicon.png">
    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="../../shared/lib/css/zenburn.css">
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = '../../shared/css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
    </script>
    <!--[if lt IE 9]>
    <script src="../../shared/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
    <div class="reveal">
        
        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section >

<h2>C# course</h2>

<h4>Lecture 5</h4>

<h1>Object-oriented programming in C#</h1>

</section>

<section >

<h3>OOP principles</h3>

<ul>
<li>Inheritance</li>
<li>Encapsulation</li>
<li>Polymorphism</li>
</ul>

<br/>
<br/>

<div class="fragment">

<h4>More OOP pronciples</h4>

<ul>
<li>Coupling/Cohesion</li>
<li>Abstration</li>
<li>S.O.L.I.D.
</div></li>
</ul>

</section>

<section >

<h3>Access modifiers in C#</h3>

<ul>
<li><strong>private</strong> - (default access modifier) - access is limited by containing type</li>
<li><strong>public</strong> - element is accessible from everywhere</li>
<li><strong>protected</strong> - access is limited by containing type and typed derived from it</li>
<li><strong>internal</strong> - access is limited by assembly where containing type is declared</li>
<li><strong>protected internal</strong> - superposition of protected and internal access levels</li>
</ul>

<div class="fragment">

<table class="pre"><tr><td><pre lang="cs"><span class="k">namespace</span> Test {
    <span class="k">public</span> <span class="k">class</span> Accesibility {
        <span class="k">private</span>            <span class="k">int</span> _private <span class="o">=</span> 10; <span class="c">// this var will be available within this class only</span>
        <span class="k">public</span>             <span class="k">int</span> _public <span class="o">=</span> 20; <span class="c">// this var will be accessible anywhere</span>
        <span class="k">protected</span>          <span class="k">int</span> _protected <span class="o">=</span> 30; <span class="c">// this var will be available withi this class and for derived classes</span>
        <span class="k">internal</span>           <span class="k">int</span> _internal <span class="o">=</span> 40; <span class="c">// this var will be available anywhere within current assembly</span>
        <span class="k">protected</span> <span class="k">internal</span> <span class="k">int</span> _protected_internal <span class="o">=</span> 50; <span class="c">// this var available within current assembly and for derived classes</span>
    }
}
</pre></td></tr></table>

<p>`
</div></p>

</section>

<section >

<section >

<h3>Interfaces as custom types</h3>

<ul>
<li>Interface is a reference type</li>
<li>Interfaces could not be instantiated</li>
<li>All members declared in an interface are public</li>
<li>Interface declares: <strong>methods</strong>, <strong>properties</strong>, <strong>indexers</strong> and <strong>events</strong></li>
<li>All members are abstract e.g. do not include any code</li>
</ul>

<p><img src="images/Interface.png" alt="Interface" /></p>

<p>Once a class implements an interfaces it takes responsibility to provide functionality declared by interface.</p>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Interface declaration</h3>

<div>

<table class="pre"><tr><td><pre lang="cs"><span class="k">public</span> <span class="k">interface</span> ISomeInterface1 {
    <span class="k">void</span> SomeMethod(); <span class="c">// declare a method</span>
    <span class="k">int</span> SomeProperty {get; set;}  <span class="c">// declare a property</span>
    <span class="k">event</span> EventHandler SomeEvent;  <span class="c">// declare an event</span>
    <span class="k">int</span> <span class="k">this</span>[<span class="k">string</span> index] {get; set;}  <span class="c">// declare an indexer</span>
}
</pre></td></tr></table>

</div>  

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Interfaces implementation</h3>

<p>Class might implement interface in 2 ways:</p>

<ul>
<li><a href="https://dotnetfiddle.net/CzfpPL">Explicit implementation</a>  <br />
Force some (or all) interface members belong to the interface directly.</li>
<li><a href="https://dotnetfiddle.net/XdmqIh">Implicit implementation</a> <br />
Share member implementation between an interface and a class which implements the interface</li>
</ul>

</section>

</section>

<section >

<section >

<h3>Encapsulation in C#</h3>

<p>Rules of thumb</p>

<ul>
<li>Hides implementation details</li>
<li>Class exposes <em>some</em> operation available for clients (its interface) other members should be hidden</li>
<li><strong>ALL</strong> data members should be hidden from client.</li>
<li>Acces to data members should be provided via properties</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Encapsulation on practice</h3>

<ul>
<li><strong>Fields</strong> <br />
Should be always declared as private and accessed via properties</li>
<li><strong>Constructors</strong> <br />
Should be declared as public (sometimes as protected)</li>
<li><strong>Interface members (properties, methods, events)</strong> <br />
Are always declared as public</li>
<li><strong>Other class members</strong> <br />
Should be declared as private or protected</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Encapsulation benefits</h3>

<ul>
<li>allows change implementations without affecting any code outside a class</li>
<li>hiding implementation from client reduces code complexity</li>
</ul>

<div class="fragment">
Example of encapsulation:

<table class="pre"><tr><td><pre lang="cs"><span class="k">class</span> Counter {
    <span class="k">private</span> <span class="k">int</span> _id, _i;
    <span class="k">private</span> <span class="k">static</span> <span class="k">int</span> s_n;

    <span class="k">public</span> Counter() {
        _id <span class="o">=</span> s_n+<span class="o">+</span>;
    }
    <span class="k">public</span> <span class="k">void</span> Increment() {
        Console.WriteLine(“{0} <span class="o">-</span><span class="o">&gt;</span> {1}”, _id, <span class="o">+</span>+_i);
    }
    <span class="k">public</span> <span class="k">void</span> Decrement() {
        Console.WriteLine(“{0} <span class="o">-</span><span class="o">&gt;</span> {1}”, _id, —_i);
    }
    <span class="k">public</span> <span class="k">int</span> Count
    {
        get { <span class="k">return</span> _i; }
    }
}
</pre></td></tr></table>

</div>

</section>

</section>

<section >

<section >

<h3>Inheritance</h3>

<p><img src="images/Inheritance.gif" alt="Inheritance" /></p>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Inheritance</h3>

<p>There are 2 kind of inheritance in C#:</p>

<ul>
<li>behaviour inheritance - inherit and extend class by its child</li>
<li>interface inheritance - implement interfaces</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Behaviour inheritance</h3>

<p>Inheritance allows child classes inherit characteristics and behaviour of parent class:</p>

<ul>
<li>characteristics - data members (properties)</li>
<li>behaviour - methods</li>
</ul>

<p>Inheritance allows child classes extend characteristics and behaviour of parent class:</p>

<ul>
<li>add new fields and/or methods</li>
<li>change behaviour of methods</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Inheritance - terminology</h3>

<ul>
<li><strong>Derived class</strong> - inherits base (parent) class</li>
<li>Class <strong>implements</strong> interface</li>
<li><strong>Derived interface</strong> extends base (parent) interface</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Inheritance - example</h3>

<p><img src="images/Inheritance_example.png" alt="Inheritance example" /></p>

</section>

</section>

<section >

<section >

<h3>Inheritance in C#</h3>

<p>A class can inherit only one class (singular implementation inheritance)</p>

<p>Class can be derived from only one parent class.</p>

<div>

<table class="pre"><tr><td><pre lang="cs"><span class="k">public</span> <span class="k">class</span> DerivedClass <span class="o">:</span> BaseClass
</pre></td></tr></table>

</div>

<p>Interfaces can extend multiple interfaces</p>

<div>

<table class="pre"><tr><td><pre lang="cs"><span class="k">public</span> <span class="k">interface</span> IDerived <span class="o">:</span> IBase1, IBase2
</pre></td></tr></table>

</div>

<p>Class can implement multiple interfaces</p>

<div>

<table class="pre"><tr><td><pre lang="cs"><span class="k">public</span> <span class="k">class</span> DerivedClass <span class="o">:</span> IBase1, IBase2
<span class="k">public</span> <span class="k">class</span> DerivedClass <span class="o">:</span> IBase1, IBase2
</pre></td></tr></table>

</div>

<a href="http://www.java-samples.com/images/diamond-inheritance.gif">Why multiple implementation inheritance terrible?</a>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>C# inheritance - example</h3>

<p><img src="images/csharp_inheritance.png" alt="CSharp inheritance example" /></p>

<a href="https://dotnetfiddle.net/iquGcU">Live demo</a>

</section>

</section>

<section >

<section >

<h3>Inheritance and constructors</h3>

<ul>
<li>each class in hierarchy can have own constructor(s)</li>
<li>class instance is created after invoking class constructor. If there is no custom constructor, default (parameterless) constructor will be invoked.</li>
<li>constructors invocation flow - first base last - derived.</li>
<li>custom contructors are optional, but once declared</li>
</ul>

<p>Examples:</p>

<ul>
<li><a href="https://dotnetfiddle.net/6iOWGH">example 1</a></li>
<li><a href="https://dotnetfiddle.net/uq56bk">example 2</a></li>
<li><a href="https://dotnetfiddle.net/pd6Gsq">example 3</a></li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>More tricks with constructors</h3>

<p><strong>base</strong> and <strong>this</strong> keywords allow developer to refer to another constructor declared in base of current class</p>

<ul>
<li><strong>base</strong> -  refers to parent class</li>
<li><strong>this</strong> - refers to current class  <br />
<br/></li>
</ul>

<a href="https://dotnetfiddle.net/InwmMX">Example</a>   

</section>

</section>

<section >

<h3>Inheritance overview</h3>

<ul>
<li>Structures do not support implementation inheritance (however support <a href="https://dotnetfiddle.net/fTmZ98">interface inheritance</a>)</li>
<li>C# does not support multiple inheritance</li>
<li>Static members could not be inherited</li>
<li>Constructors could not be inherited (you must declare own constructor and define inheritance rules)</li>
<li>Inheritance is transitive: if B -> (derived from) A and C -> B, then C -> A</li>
<li>Inheritance could be closed with keyword sealed. If class declared with this keyword it cannot have derived classes</li>
</ul>

</section>

<section >

<section >

<h3>Polymorphism</h3>

<ul>
<li><a href="http://www.codeproject.com/Articles/602141/Polymorphism-in-NET">polymorphism</a> means one name many forms</li>
<li>the same method or property can perform different actions depending on the run-time type of the instance that invokes it</li>
<li>allows abstract operation to be defined and used.</li>
<li>there are two types of polymorphism:
<ul>
<li>static or compile time polymorphism</li>
<li>dynamic or runtime polymorphism</li>
</ul></li>
</ul>

<p><img src="images/plymorphism.png" alt="Polymorphism" /></p>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Static polymorphism</h3>

<p>In static polymorphism, the decision is made at <strong>compile time</strong>.</p>

<ul>
<li>which method is to be called is decided at compile-time only</li>
<li>method overloading is an example of this</li>
<li>compile time polymorphism is method overloading, where the compiler knows which overloaded method it is going to call</li>
</ul>

<a href="https://dotnetfiddle.net/5zfroY">Demo</a>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Dynamic or runtime polymorphism</h3>

<ul>
<li>achieved by method overriding (do not mix with overloading)</li>
<li>the determination of the method to be called is based on the object being referred to by reference variable.</li>
<li>Overriding is technically could be achieved using following keywords: <strong>abstract</strong> or <strong>virtual</strong> and <strong>override</strong></li>
</ul>

<a href="https://dotnetfiddle.net/gAvzOj">Demo</a>

</section>

</section>

<section >

<section >

<h3>Virtual members</h3>

<ul>
<li>member virtualizations allows to override and add own behaviour to this member in derived class</li>
<li>by default all members in a class are not virtual</li>
<li>virtualization becomes available with keyword virtual or abstract</li>
</ul>

<div>   

<table class="pre"><tr><td><pre lang="cs"><span class="k">public</span> <span class="k">virtual</span> <span class="k">void</span> VirtualMethod()
</pre></td></tr></table>

</div>

<ul>
<li>methods declared as virtual or abstract could be overridden in derived</li>
<li>once method is overridden, it can contain own implementation different from base method</li>
</ul>

<a href="https://dotnetfiddle.net/gAvzOj">Demo</a>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3><strong>virtual</strong> keyword</h3>

<ul>
<li>declares virtual members in a class</li>
<li>applied for methods, properties, indexers and events</li>
<li>methods marked as virtual should have own implementation</li>
<li>overloaded methods could be marked as virtual</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3><strong>override</strong> keyword</h3>

<ul>
<li>using override can modify a method or a property</li>
<li>overridden method provides new implementations of a virtual member</li>
<li>non-virtual or static members could not be overridden</li>
<li>overridden method could also be overridden in derived class</li>
<li>overriding do not change member visibility (e.g. public member cannot be private after overriding)</li>
</ul>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Virtual methods in constructors</h3>

<h4>Do not invoke virtual methods in constructor</h4>

<a href="https://dotnetfiddle.net/FI1hwH">Why?</a>

</section>

</section>

<section >

<h3>Hiding members and <strong>new</strong> keyword</h3>

<ul>
<li><p>member hiding is when you declare member with the same name in derived class</p></li>
<li><p>hiding of a virtual member breaks the polymorphism (and compiler will show you a warning in this case).</p></li>
</ul>

<p>To force hiding virtual member, keyword <strong>new</strong> is used:</p>

<div>

<table class="pre"><tr><td><pre lang="cs"><span class="k">public</span> <span class="k">new</span> <span class="k">void</span> VirtualMethod() {<span class="o">.</span><span class="o">.</span><span class="o">.</span>}
</pre></td></tr></table>

<div>

<p>Hidden member could be also marked as virtual and start another chain of polymorphism:</p>

<div>

<table class="pre"><tr><td><pre lang="cs"><span class="k">public</span> <span class="k">new</span> <span class="k">virtual</span> <span class="k">void</span> VirtualMethod() {<span class="o">.</span><span class="o">.</span><span class="o">.</span>}
</pre></td></tr></table>

<div>

<a href="https://dotnetfiddle.net/SwCR3k">Demo</a>

</section>

<section >

<h3>More about polymorphism</h3>

<ul>
<li>C# allows disabling further polymorphism and inheritance in derived classes</li>
<li>keyword <strong>sealed</strong> is used for these purposes</li>
<li>sealed might be applied to classes and class members</li>
<li>once class marked with keyword sealed inheritance from this class gets deprecated</li>
</ul>

<a href="https://dotnetfiddle.net/P7yBpj">Improper sealed usage</a>   
<br />
<a href="https://dotnetfiddle.net/seZZHh">Proper sealed usage</a>

</section>

<section >

<section >

<h3>Abstract classes and members</h3>

<ul>
<li><strong>abstract</strong> classes allows to create base class with partially implemented functionality</li>
<li>abstract classes could not be instantiated (like interfaces)</li>
<li>once a member in a class marked as abstract, whole class should also be marked as abstract</li>
<li>members marked as abstract do not have any implementation.</li>
<li>class derived from an abstract class could be also abstract</li>
</ul>

<a href="https://dotnetfiddle.net/JYyxK5">Demo</a>

</section>

<section author="Valentine Radchuk" description="Object-oriented programming in C#" theme="league" title="CSharp - OOP" transition="default">

<h3>Abstract classes vs Interfaces</h3>

<ul>
<li>interface - absolutely abstract class with special support on C#</li>
<li>in abstract classes members could change their access levels (in interfaces always public)</li>
<li>abstract classes could contain some implemented methods</li>
<li>no need to override methods defined in an interface in derived class (unlike in abstract classes)</li>
<li>abstract classes can contain any members (interfaces can contain limited set of members)</li>
<li>interface is a contract between systems, abstract class is an root of hierarchy of classes</li>
</ul>

</section>

</section>



        </div>
    </div>
    <script src="../../shared/lib/js/head.min.js"></script>
    <script src="../../shared/js/reveal.js"></script>
    <script>

        // Full list of configuration options available here:
        // https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            controls: true,
            progress: true,
            history: true,
            center: true,

            transition: 'default', // default/cube/page/concave/zoom/linear/fade/none

            // Parallax scrolling
            // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
            // parallaxBackgroundSize: '2100px 900px',

            // Optional libraries used to extend on reveal.js
            dependencies: [
                { src: '../../shared/lib/js/classList.js', condition: function () { return !document.body.classList; } },
                { src: '../../shared/plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: '../../shared/plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
                { src: '../../shared/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
                { src: '../../shared/plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
                { src: '../../shared/plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
            ]
        });

    </script>
</body>
</html>

